
# Подробный разбор решения задачи

## План:
1. Загружаем HTML-страницу с сервера и извлекаем уравнение.
2. Решаем уравнение с помощью библиотеки SymPy.
3. Отправляем ответ на сервер.
4. Повторяем этот процесс для всех уравнений.
5. После решения всех уравнений, преобразуем ответы в шестнадцатеричную систему.
6. Переводим шестнадцатеричные значения в ASCII-символы и выводим результат.

---

## Шаг 1: Загружаем HTML-страницу с сервера и извлекаем уравнение

Для начала нужно загрузить HTML-страницу с веб-сервера, на которой находятся уравнения, и извлечь нужные данные (уравнение и индекс уравнения).

1. **`requests.get()`**: Используется для отправки GET-запроса к серверу по адресу `http://127.0.0.1:6969`.
   
    ```python
    z = requests.get('http://127.0.0.1:6969').text
    ```

2. **Парсинг HTML**: Используем библиотеку `BeautifulSoup` для парсинга HTML-кода страницы.

    ```python
    soup = BeautifulSoup(z, 'html.parser')
    ```

3. **Извлечение индекса уравнения**: На странице есть скрытый элемент `<input>` с индексом уравнения. Мы используем `soup.find()` для его извлечения.

    ```python
    hidden_input = soup.find('input', {'type': 'hidden', 'name': 'equation_index'})
    equation_index = hidden_input['value'] if hidden_input else None
    ```

4. **Извлечение уравнения**: Уравнение хранится в элементе `<p>`. Мы находим этот элемент и извлекаем текст уравнения.

    ```python
    equation_str = soup.find('p').text
    ```

---

## Шаг 2: Решаем уравнение с помощью SymPy

Теперь, когда уравнение извлечено, его нужно решить. Для этого используется библиотека `SymPy`.

1. **Преобразуем уравнение в символьное выражение**:
   - Сначала делим уравнение на левую и правую части по знаку равенства `"="`.
   
    ```python
    lhs, rhs = equation_str.split('=')
    ```

2. **Конвертируем строки в символьные выражения**:
   - Используем `sp.sympify()` для преобразования левой и правой части уравнения в символьные выражения.

    ```python
    lhs = sp.sympify(lhs.strip())
    rhs = sp.sympify(rhs.strip())
    ```

3. **Создаем символьное уравнение**:
   - Создаем уравнение с помощью `sp.Eq()`.

    ```python
    equation = sp.Eq(lhs, rhs)
    ```

4. **Решаем уравнение**:
   - Пытаемся найти аналитическое решение с помощью `sp.solve()`.

    ```python
    solutions = sp.solve(equation, x)
    ```

5. **Численное решение**:
   - Если не удается найти аналитическое решение, используем численный метод `sp.nsolve()`.

    ```python
    if not solutions:
        solution_numerical = sp.nsolve(equation, x)
        return [solution_numerical]
    ```

---

## Шаг 3: Отправляем ответ на сервер

После того как уравнение решено, необходимо отправить результат обратно на сервер.

1. **Сохраняем решение**:
   - Извлекаем первое решение из списка решений, так как уравнения должны иметь единственный корень.
   
    ```python
    root = solve_numerically(soup.find('p').text)[0]
    roots.append(root)
    ```

2. **Отправляем POST-запрос**:
   - С помощью `requests.post()` отправляем решение на сервер, передавая индекс уравнения и решение в качестве данных формы.

    ```python
    requests.post('http://127.0.0.1:6969', {'equation_index': equation_index, 'user_answer': root})
    ```

---

## Шаг 4: Повторяем процесс для всех уравнений

Теперь, когда мы успешно решили одно уравнение, программа продолжает процесс до тех пор, пока не закончатся все уравнения.

1. **Цикл `while True`**:
   - Программа находится в бесконечном цикле и продолжает загружать страницу, решать уравнение и отправлять решение на сервер, пока не закончатся уравнения.

    ```python
    while True:
        z = requests.get('http://127.0.0.1:6969/').text
        soup = BeautifulSoup(z, 'html.parser')
        equation_index = hidden_input['value'] if hidden_input else None
        root = solve_numerically(soup.find('p').text)[0]
        print(root)
        requests.post('http://127.0.0.1:6969', {'equation_index': equation_index, 'user_answer': root})
    ```

2. **Обработка исключений**:
   - Когда сервер больше не отправляет уравнения или происходит ошибка, программа завершает цикл и выводит список всех решенных уравнений.

    ```python
    except:
        print(z)
        break
    ```

---

## Шаг 5: Преобразуем решения в шестнадцатеричную систему

Когда все уравнения решены и решения сохранены в списке, необходимо преобразовать их в шестнадцатеричную систему.

1. **Перевод решений в шестнадцатеричный формат**:
   - Каждое число из списка корней преобразуется в шестнадцатеричное значение с помощью функции `hex()`.

    ```python
    hex_solves = [hex(int(i))[2:].upper() for i in roots]
    ```

2. **Удаление префикса `0x`**:
   - Преобразованные значения будут без префикса `0x`, а буквы в шестнадцатеричных числах будут в верхнем регистре.

---

## Шаг 6: Перевод шестнадцатеричных значений в ASCII-символы

На последнем этапе шестнадцатеричные значения необходимо преобразовать в ASCII-символы.

1. **Функция для перевода в ASCII**:
   - Используем функцию, которая преобразует каждый шестнадцатеричный символ в десятичное значение, а затем в ASCII-символ.

    ```python
    def hex_to_ascii(hex_list):
        ascii_string = ''.join([chr(int(h, 16)) for h in hex_list])
        return ascii_string
    ```

2. **Вывод строки ASCII**:
   - Преобразуем список шестнадцатеричных решений в строку и выводим результат.

    ```python
    print(hex_to_ascii(hex_solves))
    ```

---

## Заключение

Этот код:
1. Загружает уравнения с веб-сервера.
2. Решает их с помощью SymPy.
3. Отправляет ответы на сервер.
4. После решения всех уравнений, преобразует решения в шестнадцатеричные значения.
5. Преобразует шестнадцатеричные значения в ASCII-символы и выводит результат.
